# Symmetric Reference Counting (SRC)
A deterministic O(1) memory model without garbage collection.

*Author: [ZeroHat]*  
*Date: 2025-11-07*

### Введение
Когда мы говорим о подсчете ссылок (Reference Counting), все вспоминают одну боль - циклические ссылки.
Это когда два объекта ссылаются друг на друга, и ни один не может быть удалён, хотя больше нигде не используется.
Классический пример:
```
a.link = b
b.link = a
del a
del b  # ...но память всё ещё занята
```
Интерпретаторы вроде CPython решают это дополнительным «сборщиком циклов» (cycle GC), но это уже другая система, с обходом графа, непредсказуемыми паузами и дополнительными затратами.
Я задумался - а почему вообще нужны эти костыли?
Если рассматривать всё как систему связанных объектов, то область видимости (scope) - это ведь тоже объект.
Она хранит ссылки на другие объекты, увеличивая их `refcount`.
И если область удаляет ссылку, она тоже обязана уменьшить счетчик.
Классическая модель этого не делает.
### Озарение
Суть идеи проста:
область видимости - это тоже объект, участвующий в подсчете ссылок.
Именно эта «дыра» делает классический RC несовершенным:
он нарушает свои же собственные правила.
Если исправить это, и рассматривать всё, включая Env как обычный объект со своими ссылками,
то удаление переменной автоматически ведёт к корректному уменьшению `refcount` у тех, на кого она указывала.
### Визуализация
Проблема классического подсчёта ссылок заключается в том, что модель предполагает следующую структуру:
каждый объект в куче ссылается на другие объекты, а область видимости (или стек) просто «держит» ссылки на них, но сама не участвует в подсчете ссылок.
На схеме ниже видно, что на каждый элемент кучи действительно указывает лишь один предыдущий объект,
но при этом их счетчик ссылок равен 2 - один из учтенных источников ссылки фактически не существует в модели
То есть модель учитывает «магическую» внешнюю ссылку, которая нигде формально не описана.
![](https://habrastorage.org/webt/z3/rx/2f/z3rx2fumzq7u2ldb1jaxifm7pdw.png)

Решение состоит в том, чтобы считать область видимости таким же объектом,
который владеет ссылками и участвует в подсчете ссылок.
Когда переменная удаляется из области видимости, область должна уменьшить refcount
у объекта, на который она указывала.
На схеме ниже это отражено:
при удалении ссылки из стека исчезает одна из реальных ссылок на объект,
и его счетчик ссылок корректно уменьшается.
Таким образом, система становится симметричной:
область видимости, объекты и связи между ними - все подчиняются одним и тем же правилам.
![](https://habrastorage.org/webt/z-/ti/aa/z-tiaanymcarb-q_oaq4bdhyidu.png)

### Пример реализации (Python-псевдокод)
```
class Object:
	def __init__(self, name):
		self.refcount = 1
		self.ref = None
		self.name = name

	def link(self, ref):
		if self.ref != ref:
			self.ref = ref
			ref.refcount += 1

	def rc_dec(self):
		self.refcount -= 1

		if self.refcount <= 0:
			print(f"{self.name} deleted!")

	def delete(self):
		if self.ref:
			self.ref.rc_dec()
		self.rc_dec()

class Env:
	def __init__(self):
		self.objects = {}

	def new(self, name):
		self.objects[name] = Object(name)

	def get(self, name):
		return self.objects[name]

	def link(self, name, target_name):
		self.objects[name].link(self.objects[target_name])

	def delete(self, name):
		self.objects[name].delete()
		del self.objects[name]

	def print_rc(self):
		if len(self.objects) != 0:
			for obj in self.objects.values():
				print(f"RC {obj.name}: {obj.refcount}")
		else:
			print("Nothing!")
```

Тест с циклом
```
env = Env()
env.new("a")
env.new("b")

env.link("a", "b")
env.link("b", "a")

env.delete("a")
env.delete("b")

env.print_rc()
```
Вывод:
```
a deleted!
b deleted!
```
- Цикл исчез.
- Счётчики нулевые.
- Никаких обходов графа.
- Всё за O(1).

#### Что произошло на самом деле
Объекты симметрично освобождают ссылки: и входящие, и исходящие.
Область видимости (Env) теперь участвует в системе на равных правах.
Утечек больше нет, даже при циклах и самоссылках.
Модель полностью детерминированная - удаление происходит точно в момент, когда счетчик достигает нуля.



Почему это не «хак», а завершение модели
Reference counting сам по себе не ошибочный - просто незавершенный.
Он предполагает, что существует некий внешний агент (область видимости), который может забыть ссылку без `DECREF`.
Но если рассматривать всё как замкнутую систему объектов, то ни один элемент не имеет привилегий. Все действуют по одним правилам.
Получается симметричная, самодостаточная система ссылок, где:
каждый объект знает, на кого он ссылается;
при удалении он корректно «отвязывает» всех, включая себя;
не нужно дополнительного GC.
### Эксперименты
Ниже тесты, включающие:
- обычные цепочки a→b→c
- циклы a↔b
- самоссылки a→a

##### Односторонние ссылки
```
env = Env()

env.new("a")
env.new("b")

env.link("a", "b")  # a -> b

env.delete("a")
env.delete("b")

env.print_rc()
```
Результат:
```
a deleted!
b deleted!
Nothing!
```
##### Цикл из двух объектов
```
env = Env()

env.new("a")
env.new("b")

env.link("a", "b")
env.link("b", "a")

env.delete("a")
env.delete("b")

env.print_rc()
```

Результат:
```
a deleted!
b deleted!
Nothing!
```
##### Цепочка из трех ссылок
```
env = Env()

env.new("a")
env.new("b")
env.new("c")

env.link("a", "b")
env.link("b", "c")

env.delete("a")
env.delete("b")
env.delete("c")

env.print_rc()
```
Результат:
```
a deleted!
b deleted!
c deleted!
Nothing!
```
##### Самоссылка
```
env = Env()

env.new("a")

env.link("a", "a")

env.delete("a")

env.print_rc()
```

Результат:
```
a deleted!
Nothing!
```
Все дают нулевые refcount в конце, без утечек и ошибок.
### Заключение
Иногда идеи рождаются не из новых технологий, а из доведения старых до логического конца.
Reference counting не нуждается в дополнительном GC, если рассматривать весь мир объектов - включая область видимости - как единый граф владений.
Симметрический RC прост, детерминирован, и не требует обходов.
И, возможно, именно эта простота - то, чего всегда не хватало классическим системам управления памятью.
> P.S.
Код - прототип, но принцип можно перенести на любой язык: C, Rust, Swift или даже реальную VM интерпретатора.
Главное - соблюдать правило симметрии: кто создаёт ссылку - тот обязан её убрать.
